<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>soap-attachments-header-mapper · eMagiz Documentation</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;soap-attachments-header-mapper&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#soap-attachments-header-mapper&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;SOAP attachments header mapper&lt;/h1&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="soap-attachments-header-mapper · eMagiz Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://eperkowski.github.io/"/><meta property="og:description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;soap-attachments-header-mapper&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#soap-attachments-header-mapper&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;SOAP attachments header mapper&lt;/h1&gt;
"/><meta property="og:image" content="https://eperkowski.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://eperkowski.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://eperkowski.github.io/blog/atom.xml" title="eMagiz Documentation Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://eperkowski.github.io/blog/feed.xml" title="eMagiz Documentation Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="eMagiz Documentation"/><h2 class="headerTitleWithLogo">eMagiz Documentation</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/landing-page" target="_self">Docs</a></li><li class=""><a href="/docs/doc4" target="_self">API</a></li><li class=""><a href="/help" target="_self">Help</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">soap-attachments-header-mapper</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="soap-attachments-header-mapper"></a><a href="#soap-attachments-header-mapper" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SOAP attachments header mapper</h1>
<h4><a class="anchor" aria-hidden="true" id="maps-attachments-as-used-in-the-soap-with-attachments-specification-to-and-from-message-headers"></a><a href="#maps-attachments-as-used-in-the-soap-with-attachments-specification-to-and-from-message-headers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maps attachments, as used in the SOAP with Attachments specification, to and from message headers.</h4>
<p><code>SoapHeaderMapper</code> implementation that converts MIME attachments, as used in the <i>SOAP with Attachments</i> (SwA) specification, to and from message headers.</p>
<p>Incoming MIME attachments will converted to message headers, but the (binary) content of the attachments is directly written to disk to prevent reading potentially huge amounts of data into memory. Outgoing MIME attachments will be converted from these same message headers, with the content being read directly from disk. This implies that both the inbound and outbound gateways must have access to the same directory.</p>
<p>The message header used by this header mapper is named <code>emagiz_ws_attachments</code>, with its value being a <code>List</code> of attachments. Each attachment is represented as a <code>Map</code> with the following entries:</p>
<ul>
<li><code>contentId (String)</code>: the (unique) <i>Content-ID</i> of the MIME attachment</li>
<li><code>contentType (String)</code>: the <i>Content-Type</i> of the MIME attachment, e.g. <code>application/pdf</code></li>
<li><code>file (File)</code>: the file that contains the (binary) content of the MIME attachment</li>
</ul>
<p>Normally no attachments equals no <code>emagiz_ws_attachments</code> header on the message, but there is one exception: on the response message of a <i>web service outbound gateway</i> this header is <b>always</b> added, even if there were no MIME attachments in the SOAP response (in this case the header value will be an empty list). This is done to prevent the gateway from copying the original header from the request message to the response message.</p>
<p>When sending attachments with a request, this header mapper will <b>not</b> delete the files containing the content for the MIME attachments, because the web service call might need to be retried later in case of errors. It is up to the user to delete these files after the call succeeded. To make this easier you can use the <code>AttachmentHeader</code> helper class within <i>SpEL</i> expressions. For example, this expression can be used in an <i>expression evaluating request handler advice</i>:
<code>T(com.emagiz.components.ws.AttachmentHeader).copy(headers).deleteFiles()</code></p>
<p>To populate the <code>emagiz_ws_attachments</code> header without using a <i>web service inbound gateway</i>, you can use the same <code>AttachmentHeader</code> helper class. For example, this expression can be used right after a <i>file inbound channel adapter</i> to create attachment headers for files that are picked up by the adapter:
<code>T(com.emagiz.components.ws.AttachmentHeader).create().add(null, 'image/png', payload).build()</code></p>
<p>Note that the first argument for <code>add(...)</code>, the <i>Content-ID</i>, is <code>null</code> in this example: this will result in a randomly generated <code>UUID</code> being used. The second argument, the <i>Content-Type</i>, is also optional: if <code>null</code> it will default to <code>application/octet-stream</code>.</p>
<p>To read from the <code>emagiz_ws_attachments</code> header, you can simply use standard <i>SpEL</i> fuctionality. For example, <code>headers.emagiz_ws_attachments[0].file</code> returns the file containing the content of the first MIME attachment.</p>
<h4><a class="anchor" aria-hidden="true" id="ignore-incoming"></a><a href="#ignore-incoming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ignore incoming</h4>
<p>Whether to ignore incoming MIME attachments, i.e. not process them at all and (importantly) not save them to disk. If you are only ever <i>sending</i> attachments, set this to <code>true</code>: otherwise you might quickly run out of disk space, because anyone can just send any number of MIME attachments with their requests or responses.</p>
<p>Note that even when setting this to <code>true</code>, response messages of a <i>web service outbound gateway</i> will still have the <code>emagiz_ws_attachments</code> header, with its value being an empty list. This is done to prevent the gateway from copying the original header from the request message to the response message.</p>
<p>Default is <code>false</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="directory"></a><a href="#directory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Directory</h4>
<p>The directory where the (binary) content of incoming MIME attachments will be stored as files.</p>
<p>When <i>sending</i> MIME attachments this setting is not used, because the full path to the file location is read from the header information. However, when using a <i>web service inbound gateway</i> paired with a <i>web service outbound gateway</i> to forward attachments, practically speaking both gateways must have (shared) access to this directory. This can be achieved by deploying both on the same server.</p>
<p>This directory is only used when <i>ignore incoming</i> is <code>false</code>, in which case make sure to periodically cleanup old files!</p>
<h4><a class="anchor" aria-hidden="true" id="auto-create-directory"></a><a href="#auto-create-directory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto create directory</h4>
<p>Specify whether to automatically create the directory if it does not yet exist when this header mapper is being initialized.</p>
<p>If set to <code>false</code> and the directory does not exist upon initialization, an exception will be thrown.</p>
<p>Default is <code>true</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="delete-outgoing-reply-files"></a><a href="#delete-outgoing-reply-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Delete outgoing reply files</h4>
<p>Automatically delete the files on disk containing the contents for the MIME attachments after sending them in a web service <b>response</b>. When using this feature, make sure that your flow does not send any <i>incoming</i> attachments back in the response: this will cause problems as files might be deleted before the attachments have fully been received.</p>
<p>When sending attachments in a web service <b>request</b>, this header mapper will <b>not</b> delete the files containing the content for the MIME attachments, because the web service call might need to be retried later in case of errors. It is up to the user to delete these files after the call succeeded. To make this easier you can use the <code>AttachmentHeader</code> helper class within <i>SpEL</i> expressions. For example, this expression can be used in an <i>expression evaluating request handler advice</i>:
<code>T(com.emagiz.components.ws.AttachmentHeader).copy(headers).deleteFiles()</code></p>
<p>Regardless of whether you use this feature or not, make sure to periodically cleanup old files as well, otherwise files of messages that do not follow the &quot;happy flow&quot; will remain on disk forever.</p>
<p>Default is <code>true</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="id"></a><a href="#id" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Id</h4>
<p>Name that uniquely identifies this flow component.</p>
<p><i>Required</i></p>
<p>---id: soap-
attachments-
header-
mapper
title: SOAP attachments header mapper
sidebar_label: SOAP attachments header mapper
---#### Maps attachments, as used in the SOAP with Attachments specification, to and from message headers.
<code>SoapHeaderMapper</code> implementation that converts MIME attachments, as used in the <i>SOAP with Attachments</i> (SwA) specification, to and from message headers.</p>
<p>Incoming MIME attachments will converted to message headers, but the (binary) content of the attachments is directly written to disk to prevent reading potentially huge amounts of data into memory. Outgoing MIME attachments will be converted from these same message headers, with the content being read directly from disk. This implies that both the inbound and outbound gateways must have access to the same directory.</p>
<p>The message header used by this header mapper is named <code>emagiz_ws_attachments</code>, with its value being a <code>List</code> of attachments. Each attachment is represented as a <code>Map</code> with the following entries:</p>
<ul>
<li><code>contentId (String)</code>: the (unique) <i>Content-ID</i> of the MIME attachment</li>
<li><code>contentType (String)</code>: the <i>Content-Type</i> of the MIME attachment, e.g. <code>application/pdf</code></li>
<li><code>file (File)</code>: the file that contains the (binary) content of the MIME attachment</li>
</ul>
<p>Normally no attachments equals no <code>emagiz_ws_attachments</code> header on the message, but there is one exception: on the response message of a <i>web service outbound gateway</i> this header is <b>always</b> added, even if there were no MIME attachments in the SOAP response (in this case the header value will be an empty list). This is done to prevent the gateway from copying the original header from the request message to the response message.</p>
<p>When sending attachments with a request, this header mapper will <b>not</b> delete the files containing the content for the MIME attachments, because the web service call might need to be retried later in case of errors. It is up to the user to delete these files after the call succeeded. To make this easier you can use the <code>AttachmentHeader</code> helper class within <i>SpEL</i> expressions. For example, this expression can be used in an <i>expression evaluating request handler advice</i>:
<code>T(com.emagiz.components.ws.AttachmentHeader).copy(headers).deleteFiles()</code></p>
<p>To populate the <code>emagiz_ws_attachments</code> header without using a <i>web service inbound gateway</i>, you can use the same <code>AttachmentHeader</code> helper class. For example, this expression can be used right after a <i>file inbound channel adapter</i> to create attachment headers for files that are picked up by the adapter:
<code>T(com.emagiz.components.ws.AttachmentHeader).create().add(null, 'image/png', payload).build()</code></p>
<p>Note that the first argument for <code>add(...)</code>, the <i>Content-ID</i>, is <code>null</code> in this example: this will result in a randomly generated <code>UUID</code> being used. The second argument, the <i>Content-Type</i>, is also optional: if <code>null</code> it will default to <code>application/octet-stream</code>.</p>
<p>To read from the <code>emagiz_ws_attachments</code> header, you can simply use standard <i>SpEL</i> fuctionality. For example, <code>headers.emagiz_ws_attachments[0].file</code> returns the file containing the content of the first MIME attachment.</p>
<h4><a class="anchor" aria-hidden="true" id="ignore-incoming-1"></a><a href="#ignore-incoming-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ignore incoming</h4>
<p>Whether to ignore incoming MIME attachments, i.e. not process them at all and (importantly) not save them to disk. If you are only ever <i>sending</i> attachments, set this to <code>true</code>: otherwise you might quickly run out of disk space, because anyone can just send any number of MIME attachments with their requests or responses.</p>
<p>Note that even when setting this to <code>true</code>, response messages of a <i>web service outbound gateway</i> will still have the <code>emagiz_ws_attachments</code> header, with its value being an empty list. This is done to prevent the gateway from copying the original header from the request message to the response message.</p>
<p>Default is <code>false</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="directory-1"></a><a href="#directory-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Directory</h4>
<p>The directory where the (binary) content of incoming MIME attachments will be stored as files.</p>
<p>When <i>sending</i> MIME attachments this setting is not used, because the full path to the file location is read from the header information. However, when using a <i>web service inbound gateway</i> paired with a <i>web service outbound gateway</i> to forward attachments, practically speaking both gateways must have (shared) access to this directory. This can be achieved by deploying both on the same server.</p>
<p>This directory is only used when <i>ignore incoming</i> is <code>false</code>, in which case make sure to periodically cleanup old files!</p>
<h4><a class="anchor" aria-hidden="true" id="auto-create-directory-1"></a><a href="#auto-create-directory-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto create directory</h4>
<p>Specify whether to automatically create the directory if it does not yet exist when this header mapper is being initialized.</p>
<p>If set to <code>false</code> and the directory does not exist upon initialization, an exception will be thrown.</p>
<p>Default is <code>true</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="delete-outgoing-reply-files-1"></a><a href="#delete-outgoing-reply-files-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Delete outgoing reply files</h4>
<p>Automatically delete the files on disk containing the contents for the MIME attachments after sending them in a web service <b>response</b>. When using this feature, make sure that your flow does not send any <i>incoming</i> attachments back in the response: this will cause problems as files might be deleted before the attachments have fully been received.</p>
<p>When sending attachments in a web service <b>request</b>, this header mapper will <b>not</b> delete the files containing the content for the MIME attachments, because the web service call might need to be retried later in case of errors. It is up to the user to delete these files after the call succeeded. To make this easier you can use the <code>AttachmentHeader</code> helper class within <i>SpEL</i> expressions. For example, this expression can be used in an <i>expression evaluating request handler advice</i>:
<code>T(com.emagiz.components.ws.AttachmentHeader).copy(headers).deleteFiles()</code></p>
<p>Regardless of whether you use this feature or not, make sure to periodically cleanup old files as well, otherwise files of messages that do not follow the &quot;happy flow&quot; will remain on disk forever.</p>
<p>Default is <code>true</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="id-1"></a><a href="#id-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Id</h4>
<p>Name that uniquely identifies this flow component.</p>
<p><i>Required</i></p>
<p>---id: SOAP attachments header mapperSOAP attachments header mapper
---#### Maps attachments, as used in the SOAP with Attachments specification, to and from message headers.
<code>SoapHeaderMapper</code> implementation that converts MIME attachments, as used in the <i>SOAP with Attachments</i> (SwA) specification, to and from message headers.</p>
<p>Incoming MIME attachments will converted to message headers, but the (binary) content of the attachments is directly written to disk to prevent reading potentially huge amounts of data into memory. Outgoing MIME attachments will be converted from these same message headers, with the content being read directly from disk. This implies that both the inbound and outbound gateways must have access to the same directory.</p>
<p>The message header used by this header mapper is named <code>emagiz_ws_attachments</code>, with its value being a <code>List</code> of attachments. Each attachment is represented as a <code>Map</code> with the following entries:</p>
<ul>
<li><code>contentId (String)</code>: the (unique) <i>Content-ID</i> of the MIME attachment</li>
<li><code>contentType (String)</code>: the <i>Content-Type</i> of the MIME attachment, e.g. <code>application/pdf</code></li>
<li><code>file (File)</code>: the file that contains the (binary) content of the MIME attachment</li>
</ul>
<p>Normally no attachments equals no <code>emagiz_ws_attachments</code> header on the message, but there is one exception: on the response message of a <i>web service outbound gateway</i> this header is <b>always</b> added, even if there were no MIME attachments in the SOAP response (in this case the header value will be an empty list). This is done to prevent the gateway from copying the original header from the request message to the response message.</p>
<p>When sending attachments with a request, this header mapper will <b>not</b> delete the files containing the content for the MIME attachments, because the web service call might need to be retried later in case of errors. It is up to the user to delete these files after the call succeeded. To make this easier you can use the <code>AttachmentHeader</code> helper class within <i>SpEL</i> expressions. For example, this expression can be used in an <i>expression evaluating request handler advice</i>:
<code>T(com.emagiz.components.ws.AttachmentHeader).copy(headers).deleteFiles()</code></p>
<p>To populate the <code>emagiz_ws_attachments</code> header without using a <i>web service inbound gateway</i>, you can use the same <code>AttachmentHeader</code> helper class. For example, this expression can be used right after a <i>file inbound channel adapter</i> to create attachment headers for files that are picked up by the adapter:
<code>T(com.emagiz.components.ws.AttachmentHeader).create().add(null, 'image/png', payload).build()</code></p>
<p>Note that the first argument for <code>add(...)</code>, the <i>Content-ID</i>, is <code>null</code> in this example: this will result in a randomly generated <code>UUID</code> being used. The second argument, the <i>Content-Type</i>, is also optional: if <code>null</code> it will default to <code>application/octet-stream</code>.</p>
<p>To read from the <code>emagiz_ws_attachments</code> header, you can simply use standard <i>SpEL</i> fuctionality. For example, <code>headers.emagiz_ws_attachments[0].file</code> returns the file containing the content of the first MIME attachment.</p>
<h4><a class="anchor" aria-hidden="true" id="ignore-incoming-2"></a><a href="#ignore-incoming-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ignore incoming</h4>
<p>Whether to ignore incoming MIME attachments, i.e. not process them at all and (importantly) not save them to disk. If you are only ever <i>sending</i> attachments, set this to <code>true</code>: otherwise you might quickly run out of disk space, because anyone can just send any number of MIME attachments with their requests or responses.</p>
<p>Note that even when setting this to <code>true</code>, response messages of a <i>web service outbound gateway</i> will still have the <code>emagiz_ws_attachments</code> header, with its value being an empty list. This is done to prevent the gateway from copying the original header from the request message to the response message.</p>
<p>Default is <code>false</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="directory-2"></a><a href="#directory-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Directory</h4>
<p>The directory where the (binary) content of incoming MIME attachments will be stored as files.</p>
<p>When <i>sending</i> MIME attachments this setting is not used, because the full path to the file location is read from the header information. However, when using a <i>web service inbound gateway</i> paired with a <i>web service outbound gateway</i> to forward attachments, practically speaking both gateways must have (shared) access to this directory. This can be achieved by deploying both on the same server.</p>
<p>This directory is only used when <i>ignore incoming</i> is <code>false</code>, in which case make sure to periodically cleanup old files!</p>
<h4><a class="anchor" aria-hidden="true" id="auto-create-directory-2"></a><a href="#auto-create-directory-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto create directory</h4>
<p>Specify whether to automatically create the directory if it does not yet exist when this header mapper is being initialized.</p>
<p>If set to <code>false</code> and the directory does not exist upon initialization, an exception will be thrown.</p>
<p>Default is <code>true</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="delete-outgoing-reply-files-2"></a><a href="#delete-outgoing-reply-files-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Delete outgoing reply files</h4>
<p>Automatically delete the files on disk containing the contents for the MIME attachments after sending them in a web service <b>response</b>. When using this feature, make sure that your flow does not send any <i>incoming</i> attachments back in the response: this will cause problems as files might be deleted before the attachments have fully been received.</p>
<p>When sending attachments in a web service <b>request</b>, this header mapper will <b>not</b> delete the files containing the content for the MIME attachments, because the web service call might need to be retried later in case of errors. It is up to the user to delete these files after the call succeeded. To make this easier you can use the <code>AttachmentHeader</code> helper class within <i>SpEL</i> expressions. For example, this expression can be used in an <i>expression evaluating request handler advice</i>:
<code>T(com.emagiz.components.ws.AttachmentHeader).copy(headers).deleteFiles()</code></p>
<p>Regardless of whether you use this feature or not, make sure to periodically cleanup old files as well, otherwise files of messages that do not follow the &quot;happy flow&quot; will remain on disk forever.</p>
<p>Default is <code>true</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="id-2"></a><a href="#id-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Id</h4>
<p>Name that uniquely identifies this flow component.</p>
<p><i>Required</i></p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/favicon.ico" alt="eMagiz Documentation" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 eMagiz</section></footer></div></body></html>